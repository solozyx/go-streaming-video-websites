【session机制非业务逻辑而是系统逻辑】
登录Facebook 只需要登录1次 之后关闭网页 重新打开网页还是登录状态
标识用户valid状态的标识符
web应用把session写在浏览器cookie中 有过期时间 做单向检查 或者 双向检查
浏览器端做检查
server端做检查
用户登录后，server端返回sessionID
用户每次访问通过该sessionID去server端检查

session_id 登录次数是无限的自增长会有枯竭的时候用范围非常大的数 unsigned int
TTL 过期时间 session过期给用户返回错误 打开页面就是匿名登录的
login_name 用户名 session对应 用户ID也行

session处理机制
难点不是session表的设计
而是整个流程机制处理，如何完成用session_id登录，如何session过期，session校验

【session】会话机制
客户端 与 服务端 交互 http REST API 最大特点 状态不会保持 state less
为了记录客户端用户在服务端的状态 引入 session
如果不保存客户端与服务端的状态，用户之前操作的需要记录的东西就会丢失，
用户需要从头到尾重新操作一遍

登录，登录进去到第2个页面了，第2个页面要检查用户是否登录，这就是状态
但是不可能每个页面都需要让用户输入 【用户名 + 密码】

【session + cookie】
session会话机制，服务端保存用户相应状态的机制
cookie在客户端保存用户状态的机制
使用session需要一个session_id 客户端为了方便访问session 会把session_id存储到客户端cookie中
这样session和cookie发生了关系

session可以存储很多复杂的东西
用户登录状态，用户进来服务端检查到有他使用的session_id则说明该用户已经登录过了，操作可授权
如果服务端没有用户使用的session_id 则用户需要重新登录


用户首次 --> Signin / Register --> api 后续处理 生成session_id 存储在服务端的cache/db中
    --> 返回 session_id给客户端 用户已经登录了
    --> 客户端把session_id存储在cookie中

用户二次登录 不需要 用户名 + 密码 了 直接用session_id
    --> api 去服务端cache/db 校验该session_id 如果存在 说明用户是login的
    --> 在系统页面用户就不用 用户名 + 密码 登录了

系统初始化/重启 时 cache 自动去db 获取所有的session_id
更新用户session时 要写入 cache 和 db
db读写压力 在网页访问比较大的时候
db操作对IO消耗大 尽可能减少db操作 所以需要用cache 保证多读少写的情况下 加快访问速度

// check session
if isUserSessionValid = session.ValidateUserSession(req); !isUserSessionValid {
	return
}

【read limit bucket token 流控机制 和 session类似】
