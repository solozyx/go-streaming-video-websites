sql.Open()
调用数据库 sql.Open 会重复执行 虽然 sql.Open() 没有真正去连接数据库
但是同样会造成connection浪费
当并发量非常大访问量非常大 会出现半连接 半关闭 状态
server会出现很多 close wait

dbConn.Prepare(query string)
预编译，安全避免数据库攻击

stmtIns.Exec(loginName,pwd)
// 提高性能 这里 不写 defer stmtIns.Close()
stmtIns.Close()
defer在栈退出的时候才会调用，性能会有些许损耗，写对性能要求非常严格的应用少用defer

if _,err = stmtIns.Exec(loginName,pwd); err != nil {
	// 这里return后 stmtIns.Close() 执行不到 导致对象越开越多 需要使用 defer
	return
}
// 提高性能 这里 不写 defer stmtIns.Close()
defer stmtIns.Close()

// 防止撞库攻击 sql 不能使用 + 进行拼接
//  "INSERT INTO video_info (id,author_id,name,display_ctime,create_time)" +
//		" VALUES (?,?,?,?,?)" 错误
var insertSql = `INSERT INTO video_info (id,author_id,name,display_ctime,create_time)
		 VALUES (?,?,?,?,?)`


mysql> ALTER TABLE video_info MODIFY column create_time datetime default CURRENT_TIMESTAMP;
ERROR 1067 (42000): Invalid default value for 'create_time'

https://blog.csdn.net/qq_37929849/article/details/78507210
ALTER TABLE video_info MODIFY column create_time timestamp DEFAULT NOW();
ALTER TABLE comments   MODIFY column time        timestamp DEFAULT NOW();


func ListComments(vid string, from, to int) (commentList []*model.Comment, err error) {
	var querySql = ` SELECT comments.id, users.Login_name, comments.content
 					  FROM comments INNER JOIN users
 					  ON comments.author_id = users.id
					  WHERE comments.video_id = ?
					  AND comments.time > FROM_UNIXTIME(?)
					  AND comments.time <= FROM_UNIXTIME(?)`
}

comments.time > FROM_UNIXTIME(?) AND comments.time <= FROM_UNIXTIME(?)`

开始时间用 开区间
结束时间用 闭区间
从1970年开始取，取最早的一条，往早取永远都可以去到最早的一条
往晚取，如果不是闭区间 FROM_UNIXTIME 只精确到秒
如果在这一秒写入 1个记录 同时在这一秒查询
如果往晚取是开区间 租后1条记录可能漏掉
一般早时间开区间 晚时间闭区间 (早 晚]

